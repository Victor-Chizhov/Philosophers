POSIX Threads — стандарт POSIX-реализации потоков (нитей) выполнения. Стандарт POSIX.1c, Threads extensions (IEEE Std 1003.1c-1995) определяет API для управления потоками, их синхронизации и планирования.
Реализации данного API существуют для большого числа UNIX-подобных ОС (GNU/Linux, Solaris, FreeBSD, OpenBSD, NetBSD, OS X), а также для Microsoft Windows и других ОС.
Библиотеки, реализующие этот стандарт (и функции этого стандарта), обычно называются Pthreads (функции имеют приставку «pthread_»).


Различие между процессами и потоками

С помощью процессов можно организовать параллельное выполнение программ. Для этого процессы клонируются вызовами fork() или exec(), а затем между ними организуется взаимодействие средствами IPC. Это довольно дорогостоящий в отношении ресурсов процесс.
С другой стороны, для организации параллельного выполнения и взаимодействия процессов можно использовать механизм многопоточности. Основной единицей здесь является поток.
Поток представляет собой облегченную версию процесса. Чтобы понять, в чем состоит его особенность, необходимо вспомнить основные характеристики процесса.
1. Процесс располагает определенными ресурсами. Он размещен в некотором виртуальном адресном пространстве, содержащем образ этого процесса. Кроме того, процесс управляет другими ресурсами (файлы, устройства ввода / вывода и т.д.).
2. Процесс подвержен диспетчеризации. Он определяет порядок выполнения одной или нескольких программ, при этом выполнение может перекрываться другими процессами. Каждый процесс имеет состояние выполнения и приоритет диспетчеризации.

Если рассматривать эти характеристики независимо друг от друга (как это принято в современной теории ОС), то:
1. владельцу ресурса, обычно называемому процессом или задачей, присущи:
	- виртуальное адресное пространство;
	- индивидуальный доступ к процессору, другим процессам, файлам, и ресурсам ввода - вывода.
2. Модулю для диспетчеризации, обычно называемому потоком или облегченным процессом, присущи:
	- состояние выполнения (активное, готовность и т.д.);
	- сохранение контекста потока в неактивном состоянии;
	- стек выполнения и некоторая статическая память для локальных переменных;
	- доступ к пространству памяти и ресурсам своего процесса.

Все потоки процесса разделяют общие ресурсы. Изменения, вызванные одним потоком, становятся немедленно доступны другим.
При корректной реализации потоки имеют определенные преимущества перед процессами. Им требуется:
- меньше времени для создания нового потока, поскольку создаваемый поток использует адресное пространство текущего процесса;
- меньше времени для завершения потока;
- меньше времени для переключения между двумя потоками в пределах процесса;
- меньше коммуникационных расходов, поскольку потоки разделяют все ресурсы, и в частности адресное пространство. Данные, продуцируемые одним из потоков, немедленно становятся доступными всем другим потокам.

Поток — это набор инструкций, выполняемых в процессе, который может варьироваться от одного потока до нескольких. Процесс — это процесс, который выделяет память и ресурсы, которые позже используются потоком. Иногда это называют легковесным процессом, потому что они могут получить доступ к общим данным, имея собственный стек. Поскольку оно работает параллельно, производительность приложения также будет улучшена. Наличие одного и того же адресного пространства потоков и процессов означает, что обмен данными между потоками не требует больших затрат. Недостатком является то, что отказ одного потока определенно повлияет на другие потоки и сделает процесс менее жизнеспособным.

В проекте Philosophers

pthread_create - создание потока
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void *arg);
Функция pthread_create() используется для создания нового потока с атрибутами, заданными атрибутом attr , внутри процесса. Если attr имеет значение NULL, используются атрибуты по умолчанию. Если атрибуты, указанные атрибутом attr , будут изменены позже, это не повлияет на атрибуты потока. После успешного завершения pthread_create() сохраняет идентификатор созданного потока в местоположении, на которое ссылается thread .
Поток создается при выполнении start_routine с аргументом arg в качестве единственного аргумента. Если start_routine возвращает значение, эффект будет таким же, как если бы имел место неявный вызов pthread_exit () с использованием возвращаемого значения start_routine в качестве статуса выхода. Обратите внимание, что поток, в котором изначально был вызван main(), отличается от этого. Когда он возвращается из main() , эффект такой же, как если бы был неявный вызов exit() с использованием возвращаемого значения main() в качестве статуса выхода.

Состояние сигнала нового потока инициализируется следующим образом:
 - Маска сигнала наследуется от создающего потока.
 - Набор сигналов, ожидающих нового потока, пуст.
 Набор сигналов, ожидающих нового потока, пуст.
Если pthread_create() завершается ошибкой, новый поток не создается, а содержимое местоположения, на которое ссылается поток , не определено.
В случае успеха функция pthread_create() возвращает ноль. В противном случае возвращается номер ошибки, указывающий на ошибку.

Функция pthread_create() завершится ошибкой, если:
- В системе не хватило необходимых ресурсов для создания другого потока, или было бы превышено установленное системой ограничение на общее количество потоков в процессе PTHREAD_THREADS_MAX.
- Значение, указанное атрибутом , недопустимо.
- У вызывающего абонента нет соответствующего разрешения для установки необходимых параметров планирования или политики планирования.
Функция pthread_create() не возвращает код ошибки [EINTR].


pthread_join — дождаться завершения потока
int pthread_join(pthread_t thread, void **value_ptr);
Функция pthread_join () должна приостановить выполнение вызывающего потока до тех пор, пока целевой поток не завершится, если целевой поток уже не завершился. При возврате из успешного вызова pthread_join () с аргументом value_ptr, отличным от NULL, значение, переданное в pthread_exit () завершающим потоком, должно быть доступно в месте, на которое ссылается value_ptr . Когда pthread_join () завершается успешно, целевой поток завершается. Результаты нескольких одновременных вызовов pthread_join (), указывающих один и тот же целевой поток, не определены. Если поток вызывает pthread_join () отменяется, то целевой поток не должен быть отсоединен.
В случае успеха функция pthread_join () должна вернуть ноль; в противном случае должен быть возвращен номер ошибки, указывающий на ошибку.


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

void ft_print()
{
	printf("Test from thread\n");
	sleep(3);
	printf("Test from thread #2\n");
}

int main()
{
	pthread_t t1, t2;
	pthread_create(&t1, NULL,(void *)ft_print, NULL);
	pthread_create(&t2, NULL,(void *)ft_print, NULL);
	pthread_join(t1, NULL);
	pthread_join(t2, NULL);
	return 0;
}

result:
Test from thread
Test from thread
Test from thread #2
Test from thread #2


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

int x = 2;

void ft_print1()
{
	x++;
	sleep(1);
	printf("Test from thread %d\n", x);
}

void ft_print2()
{
	sleep(1);
	printf("Test from thread %d\n", x);
}

int main(int ac, char **av)
{
	(void)ac;
	(void)av;
	pthread_t t1, t2;
	if(pthread_create(&t1, NULL, (void *)ft_print1, NULL))
		return 1;
	if(pthread_create(&t2, NULL, (void *)ft_print2, NULL))
		return 2;
	if(pthread_join(t1, NULL))
		return 3;
	if(pthread_join(t2, NULL))
		return 4;
	return 0;
}

result:
Test from thread 3
Test from thread 3


Что такое состояние гонки?

Это свойство алгоритма (или программы, системы и т. д.), проявляющееся в отображении аномальных результатов или поведения из-за неудачного порядка (или относительного времени) событий.
Каждому потоку выделяется предопределенный период времени для выполнения на процессоре. Когда время, отведенное для потока, истекает, контекст потока сохраняется до его следующего включения процессора, и процессор начинает выполнение следующего потока.

Наиболее распространенным признаком состояния гонки являются непредсказуемые значения переменных, которые совместно используются несколькими потоками. Это происходит из-за непредсказуемости порядка выполнения потоков. Иногда выигрывает один поток, а иногда выигрывает другой поток. В остальное время исполнение работает корректно. Кроме того, если каждый поток выполняется отдельно, значение переменной ведет себя правильно.

Когда возникают взаимоблокировки
Тупик возникает, когда каждый из двух потоков одновременно блокирует разные переменные, а затем пытается заблокировать переменную, уже заблокированную другим потоком. В результате каждый поток прекращает выполнение и ждет, пока другой поток освободит переменную. Поскольку каждый поток удерживает переменную, которую хочет другой поток, ничего не происходит, и потоки остаются заблокированными.

Распространенным признаком взаимоблокировки является то, что программа или группа потоков перестает отвечать на запросы. Это также известно как зависание. По крайней мере два потока ожидают переменную, заблокированную другим потоком. Потоки не продолжаются, потому что ни один поток не освободит свою переменную, пока не получит другую переменную. Вся программа может зависнуть, если она ожидает завершения выполнения одного или обоих этих потоков.

Что такое thread
Процессы используются для разделения различных приложений, которые выполняются в определенное время на одном компьютере. Операционная система не выполняет процессы, а потоки. Поток — это единица выполнения. Операционная система выделяет процессорное время потоку для выполнения задач потока. Один процесс может содержать несколько потоков выполнения. Каждый поток поддерживает свои собственные обработчики исключений, приоритеты планирования и набор структур, которые операционная система использует для сохранения контекста потока, если поток не может завершить свое выполнение в течение времени, назначенного процессору. Контекст сохраняется до тех пор, пока поток в следующий раз не получит процессорное время. Контекст включает в себя всю информацию, которая требуется потоку для беспрепятственного продолжения его выполнения.

Data Race
Data race происходит, когда 2 инструкции из разных потоков обращаются к одной и той же ячейке памяти, по крайней мере, один из этих доступов является записью, и нет синхронизации, которая определяет какой-либо определенный порядок среди этих доступов.
Состояние гонки является семантической ошибкой. Это недостаток, возникающий во времени или порядке событий, который приводит к ошибочному поведению программы. Многие условия гонки могут быть вызваны гонкой данных, но это не обязательно.



Блокировка мьютекса для синхронизации потоков Linux (MUTEX)

Синхронизация потоков определяется как механизм, который гарантирует, что два или более параллельных процесса или потока не будут одновременно выполнять какой-то определенный сегмент программы, известный как критический раздел. Доступ процессов к критической секции контролируется с помощью методов синхронизации. Когда один поток начинает выполнение критической секции (сериализованный сегмент программы), другой поток должен дождаться завершения первого потока. Если не применяются надлежащие методы синхронизации, это может вызвать состояние гонки , при котором значения переменных могут быть непредсказуемыми и изменяться в зависимости от времени переключения контекста процессов или потоков.

Пример состояния гонки

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>


int x = 0;

void ft_print1()
{
	int i = 0;
	while(i < 10000)
	{
		x++;
		i++;
	}
}

int main(int ac, char **av)
{
	(void)ac;
	(void)av;
	pthread_t t1, t2;
	if(pthread_create(&t1, NULL, (void *)ft_print1, NULL))
		return 1;
	if(pthread_create(&t2, NULL, (void *)ft_print1, NULL))
		return 2;
	if(pthread_join(t1, NULL))
		return 3;
	if(pthread_join(t2, NULL))
		return 4;
	
	printf("x = %d\n", x);

	return 0;
}

result:
x = 19355

Мьютекс
- Мьютекс — это блокировка, которую мы устанавливаем перед использованием общего ресурса и освобождаем после его использования.
- Когда блокировка установлена, ни один другой поток не может получить доступ к заблокированной области кода.
- Таким образом, мы видим, что даже если поток 2 запланирован, в то время как поток 1 не получил доступ к общему ресурсу, и код заблокирован потоком 1 с помощью мьютексов, тогда поток 2 не может даже получить доступ к этой области кода.
- Так что это обеспечивает синхронизированный доступ к общим ресурсам в коде.

Инициализируется мьютекс, а затем блокировка достигается путем вызова следующих двух функций: Первая функция инициализирует мьютекс, а с помощью второй функции можно заблокировать любую критическую область кода.

1. int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr) : создает мьютекс, на который ссылается мьютекс, с атрибутами, указанными в attr. Если attr имеет значение NULL, используется атрибут мьютекса по умолчанию (NONRECURSIVE).
Возвращаемое значение
- В случае успеха pthread_mutex_init() возвращает 0, и состояние мьютекса становится инициализированным и разблокированным.
- В случае неудачи pthread_mutex_init() возвращает -1.

2. int pthread_mutex_lock(pthread_mutex_t *mutex) : блокирует объект мьютекса, который идентифицирует мьютекс. Если мьютекс уже заблокирован другим потоком, поток ожидает, пока мьютекс станет доступным. Поток, заблокировавший мьютекс, становится его текущим владельцем и остается им до тех пор, пока тот же поток не разблокирует его. Когда мьютекс имеет атрибут рекурсии, использование блокировки может быть другим. Когда этот тип мьютекса блокируется несколько раз одним и тем же потоком, счетчик увеличивается, и ни один ожидающий поток не публикуется. Поток-владелец должен вызвать pthread_mutex_unlock() такое же количество раз, чтобы уменьшить счетчик до нуля.
Возвращаемое значение
- В случае успеха pthread_mutex_lock() возвращает 0.
- В случае неудачи pthread_mutex_lock() возвращает -1.

Мьютекс можно разблокировать и уничтожить, вызвав следующие две функции: первая функция снимает блокировку, а вторая функция разрушает блокировку, чтобы ее нельзя было использовать где-либо в будущем.

1. int pthread_mutex_unlock(pthread_mutex_t *mutex) : освобождает объект мьютекса. Если один или несколько потоков ожидают блокировки мьютекса, pthread_mutex_unlock() заставляет один из этих потоков вернуться из pthread_mutex_lock() с полученным объектом мьютекса. Если ни один поток не ожидает мьютекс, мьютекс разблокируется без текущего владельца. Когда мьютекс имеет атрибут рекурсии, использование блокировки может быть другим. Когда этот тип мьютекса блокируется несколько раз одним и тем же потоком, то разблокировка уменьшит счетчик, и ни один ожидающий поток не будет отправлен для продолжения работы с блокировкой. Если счетчик уменьшается до нуля, то мьютекс освобождается, и если какой-либо поток ожидает его, он публикуется.
Возвращаемое значение
- В случае успеха pthread_mutex_unlock() возвращает 0.
- В случае неудачи pthread_mutex_unlock() возвращает -1

2. int pthread_mutex_destroy(pthread_mutex_t *mutex) : удаляет объект мьютекса, который идентифицирует мьютекс. Мьютексы используются для защиты общих ресурсов. mutex имеет недопустимое значение, но его можно повторно инициализировать с помощью pthread_mutex_init().
Возвращаемое значение
- В случае успеха pthread_mutex_destroy() возвращает 0.
- В случае неудачи pthread_mutex_destroy() возвращает -1.


#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

pthread_mutex_t mutex;

int x = 0;

void ft_print1()
{
	//3 блокируем мьютекс
	pthread_mutex_lock(&mutex);


	int i = 0;
	while(i < 10000000)
	{
		x++;
		i++;
	}
	//4 разблокируем мьютекс
	pthread_mutex_unlock(&mutex);
}

int main(int ac, char **av)
{
	(void)ac;
	(void)av;
	pthread_t t1, t2;
	
	//1 инициализация
	pthread_mutex_init(&mutex, NULL);

	if(pthread_create(&t1, NULL, (void *)ft_print1, NULL))
		return 1;
	if(pthread_create(&t2, NULL, (void *)ft_print1, NULL))
		return 2;
	if(pthread_join(t1, NULL))
		return 3;
	if(pthread_join(t2, NULL))
		return 4;
	
	//2 очистка (удаление) мьютекса
	pthread_mutex_destroy(&mutex);
	
	
	printf("x = %d\n", x);

	return 0;
}

result:
x = 20000000

Как создать потоки в цикле?

как можно заметить при создании потока используется 2 функции, которые при условии проверок могут занимать до 4 строчек кода, каак упросить данное рещение, если нужно создать 8 потоков?

1. Создать массив потоков

pthread_mutex_t mutex;

int x = 0;

void ft_print1()
{
	pthread_mutex_lock(&mutex);
	int i = 0;
	while(i < 10000000)
	{
		x++;
		i++;
	}
	pthread_mutex_unlock(&mutex);
}

int main(int ac, char **av)
{
	pthread_t th_arr[4];
	pthread_mutex_init(&mutex, NULL);
	int i = 0;
	while(i < 4)
	{
		if(pthread_create(&th_arr[i], NULL, (void *)ft_print1, NULL))
			return 1;
		
		if(pthread_join(th_arr[i], NULL))
			return 1;
		i++;
	}
	pthread_mutex_destroy(&mutex);
	printf("x = %d\n", x);
	return 0;
}

Но проблема такой инициализации заключается в том, что потоки создаются поочереди, отсюда концепция многопоточности теряет свой смысл
Для того? чтобы создать многопоточность в параллельной работе функцию join нужно вынести в отдельный цикл

pthread_mutex_t mutex;

int x = 0;

void ft_print1()
{
	pthread_mutex_lock(&mutex);
	int i = 0;
	while(i < 10000000)
	{
		x++;
		i++;
	}
	pthread_mutex_unlock(&mutex);
}

int main(int ac, char **av)
{
	pthread_t th_arr[4];
	pthread_mutex_init(&mutex, NULL);
	int i = 0;
	while(i < 4)
	{
		if(pthread_create(&th_arr[i], NULL, (void *)ft_print1, NULL))
			return 1;
		i++;
	}
	i = 0;
	while(i < 4)
	{
		if(pthread_join(th_arr[i], NULL))
			return 1;
		i++;
	}

	pthread_mutex_destroy(&mutex);
	printf("x = %d\n", x);
	return 0;
}

2. Протестить вариант со списком

Максимальное колличество одновременных потоков

Есть несколько "понятий" для процесса/потока.

Физически - не более колличества ядер процессора. Т.е. если процессор 4-х ядерный, он не может выполнять более 4-х потоков одновременно. Есть технология Hyper-threading суть которой - оптимизация "переключений" между процессами, т.е. Hyper-Threading 4-8 не означает что 8 выполняются одновременно, а означает что переключение между потоками организовано таким образом, что создаётся впечатление что ядер больше.

Логически (уровень ОС) - пока не закончится память хандлов (т.е. много). Ваш вопрос сводится к макc колличество хандлов (т.к. каждому thread нужно присвоить хандл) тогда ответ - до 10000 (минус штук 300 используется системой). Активные хандлы ОС "преобразует" в таски, а процессор аппаратным решением выбирает какой таск выполнять сейчас на аппаратном уровне. Хандлами могут быть - файлы, pipes, event, mailslot и другие обьекты ОС, если программа активно использует хандлы (например для каждого thread открывается file) то хандлы закончатся в два раза быстрее, т.к. общее число ханлов не должно превышать 10000.

Уровень DOT NET. У с# Thread - это обьект за которым может быть а может не быть реального Thread Handle. Кроме того, хандлы обьеденяются в пул (для повторного использования). Активный Thread всегда подкреплен Thread Handle ОС, но неактивые можно создавать - пока не закончится память Heap. При превышении определённого числа активных Thread - получим ошибку, что не возможно создать хандл.

Апаратный уровнь. TSS или Task Gate Descriptor Для 32 битных процессоров, существует каталог GDT - таблица таблиц на 8192 ячеек. В каждой можно сохранить ссылку на 8192 LDT елементов, один из которых может быть дескриптором процесса Task-и (частью Thread без которой процессор не сможет аппаратно переключать Thread. Т.е. 67 108 864 - это "теоретически" предел аппаратных мест для потоков, но... нужно учесть, что дескрипторы памяти так же нужно разместить в этой таблице, т.е. минус дескрипторы памяти... выйдет от миллиона до 60 миллионов. Но в реальности, есть предел, выше которого процессор будет "ничем другим не занят кроме как переключением процессов", поэтому... столько не используют. Процессор распределает эти таски между ядрами апаратным решением. Что ОС будет делать когда они закончатся - скорее всего у ОС встроен константой предел на колличество тасков, так как при слишком большом их колличестве процессор начнёт терять производительность.

Ccылки по аппаратной части:

http://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol3/o_fe12b1e2a880e0ce-246.html
http://en.wikipedia.org/wiki/Global_Descriptor_Table





/*

1. основной подход использование алгоритма дэйкстры
2. каждый философ должен брать вилку с наименьшим номером из доступных
3. либфт запрещен
4. можно использовать принтф


	1. отвалидировать подающиеся аргументы
	2. создать потоки в зависимости от количества философов 
		1. использовать функцию криейт
		2. в аргументе функции использовать функцию которая будет имитировать работу фило
		3. вилки использовать как лефт райт, упоковать и в структуру и потом подавать в качестве оргументов в функцию криейт аргументы в виде структуры
		4. джойнить либо детачить в самом конце программы. когда потоки завершили свою работу
		5. 
	3. создать бесконечный цикл который будет чекать фило на смерь
		1. поставить иф с функцией проверки на дайд
			if(is_died(philo))
				//join all
		2. return 0
	4. функция фило
		1. void *philo(void *data)
			{
				while(1)
					lock(left)
					print(take left)
					lock(right)
					print(take right)
					print(phili eting)
					get_time_of_day
					usleep(time_to_eat * 1000)
					unlock(left)
					unlock (right)
					print("sleeping")
					usleep(time_to_sleep);
					print("thinking")
						
			}
	5. защить поток вывода
		lock()
		printf()
		unlock
	6. организовать потоки философов с задержкой
		1. каждый философ имеет номер
		2. перед входом в функцию поставить проверку с условием 
			if (data->num % 2 == 0)
				usleep(2500)
	7. для сздания функции is died  нужно создать отдельный поток, который будет првоверять состояние потока философа
		1.  получаем текущее время
		2.	смотрим last_eating_die 
		3.	вычитаем разницу
		4.	переводим в милисекунды
		5.	и если это значение оказалось больше time to die - он умер
		6.	

	8. стуктура философа
		philo-data
		{
			int time_to_die
					_to_sleep
					_to_eat
			mutex *left			по алгоритму дейкстры хранить минимальный номер и максимальный номер
			mutex *right
			struct time_val last_eating_time - 	по сабжекту доступен системный вызов int get_time_of_day(struct time val, 0)
			{
				long	tv_sec 
				long	tv_usec [0, 1000000] - время показывает интервал между секундами
				чтобы перевести время в милисек tv_sec * 1000 + tv_usec / 1000 - текущее время
				int must_die - защитить мьютексом


			}
			чтобы использовать время можно в самом начале программы делать вызов get_time_of_day сохранить текущее время в какой нибудь структуре
			long time и конечный результат будет time - текущее время


		}
	9. отредачить usleep
		1. void my_sleep(int ms)
			{
				struct time val start;
				struct time val now;
				gettimeofday(&start, 0);
				gettimeofday(&now, 0);
				while(now->tv_sec - start->tv_sec) * 1000 + (now->tv_usec - start->tv_usec) / 1000 < ms
				{
					usleep(10);
					get_time_of_day(&now, 0);
				}



				
			}

*/